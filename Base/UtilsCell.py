#!/bin/python

import numpy as np
import os,copy

import math 

from Base.Atoms import Atom
from Base.Cells import Cell
from Base.Clusters import Cluster

'''
	#
	# -------------------------------------------------------------------------------------------------
	# FHIaims output handling
	# -------------------------------------------------------------------------------------------------
	#

	* Synopsis:

		16.10.2023

		(1) def read_fhiaims_cell(path)

			Read periodic FHIaims geometry.in compatible text file

		(2) def find_MX_clusters(cell,M='',X='',cutd=4.0): find possible clusters formed by M-X within 'cutd' 

			Input	: cell <Cell>
			Return	: <Cluster>[]

		(3) def merge_clusters(clusters): merging clusters - generated by (2) - into a single cluster by removing duplicated atoms


	# REQ:

	Reporting internal cell : A. beta_angles (3) . delta_beta_angles (3) / B. delta_d (8) / C. SigmaSquraed (8)
	Reporting cell			: lattice constants / lattice angles / lattice volume / energy /

	1. delta_d
	2. sigma_squared

	3. delta_beta

	done
	lattice_constants
	lattice_angles
	lattice_volume
	energy

'''

#
#	Basic utils
#
def get_distance(atomA,atomB,cell=None):

	# if cell is None -> 0d : cluster
	if cell == None:
		cartA = np.array(atomA.get_cart())
		cartB = np.array(atomB.get_cart())
		dcart = cartA - cartB 
		dist = np.linalg.norm(dcart)
	# cell -> 3d PBC
	else:
		fracA = atomA.get_frac()
		fracB = atomB.get_frac()
		dfrac  = [ 0. for i in range(3) ]

		# i: 1,2,3 -> vector 'a','b','c'
		for i in range(3):
			if fracA[i] - fracB[i] <= -0.5:
				fracB[i] = fracB[i] - 1.0
				dfrac[i] = fracA[i] - fracB[i]
			elif 0.5 <= fracA[i] - fracB[i]:
				fracB[i] = fracB[i] + 1.0
				dfrac[i] = fracA[i] - fracB[i]
			else:
				dfrac[i] = fracA[i] - fracB[i]
		dist_vector = np.dot(np.array(cell.get_lattice_matrix()),np.array(dfrac))
		dist = np.linalg.norm(dist_vector)
	return dist

#
#	(1) Read FHIaims periodic cell : Return <Cell>
#
def read_fhiaims_cell(path):

	exist = os.path.exists(path)

	if exist is False:
		return False
	
	cell = Cell()
	#
	#	First pass
	#
	lvectors = []

	with open(path,'r') as f:
		for line in f:
			# pass empty line
			if line.strip() == '':
				continue
			# else get workd
			else:
				words = line.split()
			# pass commented line
			if line[0] == '#':
				continue
			if words[0] == 'lattice_vector':
				lvectors.append(list(map(float,words[1:])))

	cell.set_lattice(lvectors=lvectors)
	#print(cell.get_lvectors())
	#print(cell.get_lvolume())
	#print(cell.get_langles())
	#print(cell.get_lconstants())

	#
	#	Second pass
	#
	with open(path,'r') as f:

		for line in f:
			# pass empty line
			if line.strip() == '':
				continue
			# else get word
			else:
				words = line.split()
			# if fractional used
			if words[0] == 'atom_frac':

				frac = list(map(float,words[1:4]))
				element = words[4]

				atom = Atom()
				atom.set_atom3d(element,lvectors,frac,mode='frac')
				cell.add_atom(atom)
			# if cartesian used
			if words[0] == 'atom':

				cart = list(map(float,words[1:4]))
				element = words[4]

				atom = Atom()
				atom.set_atom3d(element,lvectors,cart,mode='cart')
				cell.add_atom(atom)

	return cell


#
#	(2) Find possible cluster formed by M-X cutd 4.0 Angstrom (default)
#
def find_MX_clusters(cell,M='',X='',cutd=4.0):

	#print('find MX * * *')
	#print(cell.get_lvectors())

	clusters = []

	for atomM in cell.get_atoms():

		if atomM.get_element() == M:		
			# create cluster
			cluster = Cluster()
			# create atom
			atom = Atom()
			atom.set_atom0d(atomM.get_element(),atomM.get_cart())
			# add atom to cluster
			cluster.add_atom(atom)

			for atomX in cell.get_atoms():

				if atomX.get_element() == X:

					fracM = atomM.get_frac()		# get copy
					fracX = atomX.get_frac()		# get copy
					# workspace
					dfrac  = [ 0. for i in range(3) ]

					for i in range(3):
						if fracM[i] - fracX[i]	<= -0.5:
							fracX[i] = fracX[i] - 1.0
							dfrac[i]  = fracM[i] - fracX[i]
						elif 0.5 <= fracM[i] - fracX[i]:
							fracX[i] = fracX[i] + 1.0
							dfrac[i] = fracM[i] - fracX[i]
						else:
							dfrac[i] = fracM[i] - fracX[i]
					# calculate distance
					dist_vector = np.dot(np.array(cell.get_lattice_matrix()),np.array(dfrac))
					dist = np.linalg.norm(dist_vector)

					if dist < cutd:
						cart = np.dot(np.array(cell.get_lattice_matrix()),np.array(fracX)).tolist()
						# create atom
						atom = Atom()
						atom.set_atom0d(atomX.get_element(),cart)
						# add atom to cluster
						cluster.add_atom(atom)

			if cell.lsorted is True:
				# use cell.sort_lattice_reference <list:float>[3]
				lc = copy.copy(cell.sort_lattice_reference)

				for i in range(2):
					for j in range(2-i):
						if lc[j] > lc[j+1]:

							lc_tmp = lc[j]
							lc[j] = lc[j+1]
							lc[j+1] = lc_tmp

							for atom in cluster.get_atoms():

								cart_tmp = atom.cart[j]
								atom.cart[j] = atom.cart[j+1]
								atom.cart[j+1] = cart_tmp

								if j == 0:
									atom.cart[2] = -atom.cart[2]
								if j == 1:
									atom.cart[0] = -atom.cart[0]

				clusters.append(cluster)
			else:
				clusters.append(cluster)

	return clusters

#
#	(2-1) Find possible cluster formed by M-X cutd 4.0 Angstrom (default)
#
def find_MX_clusters_pnma(cell,M='',X='',cutd=4.0):

	#print('find MX * * *')
	#print(cell.get_lvectors())

	clusters = []

	count = 0

	#cell.lsorted = False

	for atomM in cell.get_atoms():

		if atomM.get_element() == M:		

			count = count + 1

			# create cluster
			cluster = Cluster()
			# create atom
			atom = Atom()
			atom.set_atom0d(atomM.get_element(),atomM.get_cart())
			# add atom to cluster
			cluster.add_atom(atom)

			for atomX in cell.get_atoms():

				if atomX.get_element() == X:

					fracM = atomM.get_frac()		# get copy
					fracX = atomX.get_frac()		# get copy
					# workspace
					dfrac  = [ 0. for i in range(3) ]

					for i in range(3):
						if fracM[i] - fracX[i]	<= -0.5:
							fracX[i] = fracX[i] - 1.0
							dfrac[i]  = fracM[i] - fracX[i]
						elif 0.5 <= fracM[i] - fracX[i]:
							fracX[i] = fracX[i] + 1.0
							dfrac[i] = fracM[i] - fracX[i]
						else:
							dfrac[i] = fracM[i] - fracX[i]
					# calculate distance
					dist_vector = np.dot(np.array(cell.get_lattice_matrix()),np.array(dfrac))
					dist = np.linalg.norm(dist_vector)

					if dist < cutd:
						cart = np.dot(np.array(cell.get_lattice_matrix()),np.array(fracX)).tolist()
						# create atom
						atom = Atom()
						atom.set_atom0d(atomX.get_element(),cart)
						# add atom to cluster
						cluster.add_atom(atom)
			
			# FOR NEW CLUSTER
			ncluster = Cluster()
			lvectors = cell.get_lvectors()

			case_x = False
			case_y = False
			# sign setter depending on 'M' atom position
			for atom in cluster.get_atoms():
				if atom.get_element() == M:
					cart = atom.get_cart()
					if math.fabs(cart[0]) < math.fabs(cart[1]):
						case_y = True
						if cart[2] > 0.:
							case_y = False
							case_x = True
					if math.fabs(cart[0]) > math.fabs(cart[1]):
						case_x = True
						if cart[2] > 0.:
							case_x = False
							case_y = True
					break

			for atom in cluster.get_atoms():

				element = atom.get_element()
				cart	= atom.get_cart()

				#if count == 1 or count == 3:
				#	ncart = (np.array(cart) + np.array(lvectors[1])).tolist()
				#elif count == 2 or count == 4:
				#	ncart = (np.array(cart) + np.array(lvectors[0])).tolist()

				#if math.fabs(cart[0]) < math.fabs(cart[1]):
				#	ncart = (np.array(cart) + np.array(lvectors[1])).tolist()
				#if math.fabs(cart[0]) > math.fabs(cart[1]):
				#	ncart = (np.array(cart) + np.array(lvectors[0])).tolist()

				if case_y == True:
					ncart = (np.array(cart) + np.array(lvectors[1])).tolist()
				if case_x == True:
					ncart = (np.array(cart) + np.array(lvectors[0])).tolist()
				
				natom = Atom()
				natom.set_atom0d(element,ncart)
				ncluster.add_atom(natom)

			# sorting -------------------------------------------------------
			# if cell sorted
			if cell.lsorted is True:
				# use cell.sort_lattice_reference <list:float>[3]
				lc = copy.copy(cell.sort_lattice_reference)

				for i in range(2):
					for j in range(2-i):
						if lc[j] > lc[j+1]:

							lc_tmp = lc[j]
							lc[j] = lc[j+1]
							lc[j+1] = lc_tmp

							for atom in cluster.get_atoms():

								cart_tmp = atom.cart[j]
								atom.cart[j] = atom.cart[j+1]
								atom.cart[j+1] = cart_tmp

								if j == 0:
									atom.cart[2] = -atom.cart[2]
								if j == 1:
									atom.cart[0] = -atom.cart[0]

				clusters.append(cluster)
			else:
				clusters.append(cluster)


			# FOR NEW CLUSTER
			if cell.lsorted is True:
				# use cell.sort_lattice_reference <list:float>[3]
				lc = copy.copy(cell.sort_lattice_reference)

				for i in range(2):
					for j in range(2-i):
						if lc[j] > lc[j+1]:

							lc_tmp = lc[j]
							lc[j] = lc[j+1]
							lc[j+1] = lc_tmp

							for atom in ncluster.get_atoms():

								cart_tmp = atom.cart[j]
								atom.cart[j] = atom.cart[j+1]
								atom.cart[j+1] = cart_tmp

								if j == 0:
									atom.cart[2] = -atom.cart[2]
								if j == 1:
									atom.cart[0] = -atom.cart[0]

				clusters.append(ncluster)
			else:
				clusters.append(ncluster)

	return clusters

#
#	(3) Mergin clusters - generated by (2) - into a single cluster by removing duplicated atoms
#
def merge_clusters(clusters):

	Wcluster = Cluster()
	Rcluster = Cluster()
	duplist = []

	# load clusters
	for cluster in clusters:
		atoms = cluster.get_atoms()
		for atom in atoms:
			Wcluster.add_atom(atom)		

	# remove duplicates
	atomlist = Wcluster.get_atoms()
	for i in range(len(atomlist)):
		carti = atomlist[i].get_cart()
		for j in range(i+1,len(atomlist)):
			cartj = atomlist[j].get_cart()

			# duplicated check
			rij = np.linalg.norm(np.array(carti)-np.array(cartj))
			if rij < 10E-8:
				duplist.append(j)

	for i in range(len(atomlist)):
		if i not in duplist:
			Rcluster.add_atom(atomlist[i])

	return Rcluster

#
# 04.24 added 
#
def cluster_dump_excessX(clusters, max_X_count):
	"""
	Remove excess X atoms from clusters if the total number of X atoms exceeds max_X_count.

	Args:
	clusters (list): List of clusters where each cluster is an ASE Atoms object.
	max_X_count (int): Maximum number of X atoms allowed in a cluster.

	Returns:
	list: Updated list of clusters after removing excess X atoms.
	"""
	updated_clusters = []

	for cluster in clusters:
		# Centric atom is the first atom in the cluster (e.g., 'A' atom)
		centric_atom = cluster.get_atoms()[0]

		# Check if the number of atoms in the cluster exceeds max_X_count
		while cluster.get_number_of_atoms() > max_X_count + 1:
			dist_list = []

			# Calculate distances to atoms in the cluster
			for atom in cluster.get_atoms():
				if atom.get_element() == centric_atom.get_element():  # Skip if 'Cs'
					continue
				dist_list.append(get_distance(centric_atom, atom))

			# Find the index of the atom with the maximum distance from the centric atom
			if dist_list:
				max_index = dist_list.index(max(dist_list))
				# Delete the atom with the maximum distance (add 1 to index to adjust for ASE atom indexing)
				cluster.del_atom(max_index + 1)

		# Append the updated cluster to the list of updated_clusters
		updated_clusters.append(cluster)

	return updated_clusters
"""
	# Usage example
	f_clusters_ax = find_MX_clusters(cell_final, M='Cs', X='I', cutd=8.0)
	max_X_allowed = 13
	updated_clusters = dump_excess_X_clusters(f_clusters_ax, max_X_allowed)
"""


#	------------------------------------------------------------------------------
#		Geometric data extracting functions
#	------------------------------------------------------------------------------

#
#	A. Delta D calculator : 'clusters' -> 8 Oh clusters list
#
def calculate_delta_d(clusters,bond_cnt=6.,C='',S=''):
	
	# delta_d list
	ddlist = []

	# looping 8 clusters
	for cluster in clusters:
		atoms = cluster.get_atoms()
		dlist = []
		dave = 0.
		delta_d = 0.

		for atomC in atoms:
			if atomC.get_element() == C:

				for atomS in atoms:
					if atomS.get_element() == S:
						dlist.append(get_distance(atomC,atomS))

		dave = np.mean(np.array(dlist))

		for d in dlist:
			delta_d = delta_d + (d - dave)*(d - dave) / dave / dave
		delta_d = delta_d/float(bond_cnt)

		ddlist.append(delta_d)

	return ddlist
#
#	B. SigmaSqured calculator : 'clusters' -> 8 Oh clusters list
#
def calculate_sigma_squared(clusters,C='',S='',cuta=120.):

	# ss list
	sslist = []
	
	# looping 8 clusters
	for cluster in clusters:

		atoms = cluster.get_atoms()
		thelist = []
		sigsqr = 0.
		atomC = None

		# get centric atom 'C'
		for atom in atoms:
			if atom.get_element() == C:
				atomC = atom

		# get surr atom 'S'
		atomS_list = []
		for atom in atoms:
			if atom.get_element() == S:
				atomS_list.append(atom)
		
		# calculate S-C-S cis angles
		for i in range(len(atomS_list)):
			for j in range(i+1,len(atomS_list)):

				rcs1 = np.array(atomS_list[i].get_cart()) - np.array(atomC.get_cart())
				rcs2 = np.array(atomS_list[j].get_cart()) - np.array(atomC.get_cart())

				RCS1 = get_distance(atomS_list[i],atomC)
				RCS2 = get_distance(atomS_list[j],atomC)

				the = np.dot(rcs1,rcs2) / RCS1 / RCS2
				the = np.clip(the,-1.0,1.0)
				the_rad = np.arccos(the)
				the_deg = np.degrees(the_rad)

				if the_deg < cuta:
					thelist.append(the_deg)

		for the in thelist:
			sigsqr = sigsqr + (the-90.)*(the-90.)/11.

		sslist.append(sigsqr)

	return sslist

#
#	C. Beta angle extractor: M-X-M angle, 'cluster' 8 Oh clusters after removing duplicates
#
def calculate_beta(cluster,C='',S='',cutd=4.0):

	beta_a = []
	beta_b = []
	beta_c = []
	
	for atomC in cluster.get_atoms():

		if atomC.get_element() == C:
			surr_atomlist = []
			rc = atomC.get_cart()

			for atomS in cluster.get_atoms():

				if atomS.get_element() == S:
					rs = atomS.get_cart()

					if np.linalg.norm(np.array(rc)-np.array(rs)) < cutd:
						surr_atomlist.append(atomS)

			if len(surr_atomlist) == 2:

				rc = np.array(rc)
				rs1 = np.array(surr_atomlist[0].get_cart())
				rs2 = np.array(surr_atomlist[1].get_cart())
				rcs1 = rs1 - rc
				rcs2 = rs2 - rc

				RCS1 = np.linalg.norm(rcs1)
				RCS2 = np.linalg.norm(rcs2)

				beta = np.dot(rcs1,rcs2)/RCS1/RCS2
				beta = np.clip(beta,-1.0,1.0)
				beta_rad = np.arccos(beta)
				beta_deg = np.degrees(beta_rad)

				# get direction
				dvector = (np.array(rs1) - np.array(rs2)).tolist()
				for i,elem in enumerate(dvector):
					if elem < 0.:
						dvector[i] = -dvector[i]
				dir_idx = dvector.index(max(dvector))
				if dir_idx == 0:
					beta_a.append(beta_deg)
				elif dir_idx == 1:
					beta_b.append(beta_deg)
				else:
					beta_c.append(beta_deg)

	return beta_a,beta_b,beta_c

#
#	C - 2. Beta angle extractor: M-X-M angle, 'cluster' 8 Oh clusters after removing duplicates
#
def calculate_beta_pnma(cluster,C='',S='',cutd=4.0):

	beta_a = []
	beta_b = []
	beta_c = []
	
	for atomC in cluster.get_atoms():

		if atomC.get_element() == C:
			surr_atomlist = []
			rc = atomC.get_cart()

			for atomS in cluster.get_atoms():

				if atomS.get_element() == S:
					rs = atomS.get_cart()

					if np.linalg.norm(np.array(rc)-np.array(rs)) < cutd:
						surr_atomlist.append(atomS)

			if len(surr_atomlist) == 2:

				rc = np.array(rc)
				rs1 = np.array(surr_atomlist[0].get_cart())
				rs2 = np.array(surr_atomlist[1].get_cart())
				rcs1 = rs1 - rc
				rcs2 = rs2 - rc

				RCS1 = np.linalg.norm(rcs1)
				RCS2 = np.linalg.norm(rcs2)

				beta = np.dot(rcs1,rcs2)/RCS1/RCS2
				beta = np.clip(beta,-1.0,1.0)
				beta_rad = np.arccos(beta)
				beta_deg = np.degrees(beta_rad)

				# get direction
				dvector = (np.array(rs1) - np.array(rs2)).tolist()
				#print(dvector)
				for i,elem in enumerate(dvector):
					if elem < 0.:
						dvector[i] = -dvector[i]
				dir_idx = dvector.index(max(dvector))
				#if dir_idx == 0:
				#	beta_a.append(beta_deg)
				#elif dir_idx == 1:
				#	beta_b.append(beta_deg)
				#else:
				#	beta_c.append(beta_deg)

				if dir_idx == 2:
					beta_c.append(beta_deg)
				else:

					dvector = (np.array(rs1) - np.array(rs2)).tolist()

					if dvector[0] * dvector[1] > 0.:
						beta_a.append(beta_deg)
					elif dvector[0] * dvector[1] < 0.:
						beta_b.append(beta_deg)

	return beta_a,beta_b,beta_c


#
#	D. R1 - R0 : R1 after VVUQ uncertainty application, R0 original sample
#
def calculate_deltaR(cell1,cell0,elem=False):

	elemlist = []
	signtable = []
	deltaR = []
	rmsd = 0.

	atomlist1 = cell1.get_atoms()
	atomlist0 = cell0.get_atoms()

	for atom1, atom0 in zip(atomlist1,atomlist0):

		if elem == True: # functionality addition 02.05.2024
			elemlist.append(atom1.get_element())

		r1 = np.array(atom1.get_cart())
		r0 = np.array(atom0.get_cart())
		dr = (r1 - r0)

		dr_sqr = np.dot(dr,dr)
		rmsd = rmsd + dr_sqr

		dr = dr.tolist()

		for item in dr:
			if -5.E-9 < item and item < 5.E-9:
				item = 0.
			deltaR.append(item)

			if item > 0.:
				sign = +1
			elif item < 0.:
				sign = -1
			else:
				sign = 0

			signtable.append(sign)

	rmsd = np.sqrt(rmsd)
	#print(len(deltaR),len(signtable))
	if elem == False:
		return deltaR, signtable, rmsd

	if elem == True:
		return elemlist, deltaR, signtable, rmsd


if __name__ == '__main__':

	#cell = read_fhiaims_cell('/work/e05/e05/wkjee/PAX/VVUQ/Perovskite/UQ_CsPbI/Move_Atoms_E0.5.2/MoveX/local_177/run__7otq69o9/runs/run_1/geometry.in')
	#print('-- fhiaims fractional')
	#cell.write_fhiaims(rule='frac',stdout=True)
	#print('-- fhiaims cartesian')
	#cell.write_fhiaims(rule='cart',stdout=True)

	print('-- test 2')
	#cell = read_fhiaims_cell('/work/e05/e05/wkjee/PAX/VVUQ/Perovskite/UQ_CsPbI/Move_Atoms_E1.3/MoveX/summary_1-210/180_aims_final.in')
	cell = read_fhiaims_cell('/work/e05/e05/wkjee/PAX/VVUQ/Perovskite/UQ_CsPbI/Move_Atoms_E1.3/MoveA/local_103/run__v0ph_o3m/runs/run_3/geometry.in.next_step')
	print('-- fhiaims fractional')
	cell.write_fhiaims(rule='frac',stdout=True)
	print('-- fhiaims cartesian')
	cell.write_fhiaims(rule='cart',stdout=True)


	print('-- test 3')
	print('Lvectors:	',cell.get_lvectors())
	print('Lvolume:		',cell.get_lvolume())
	print('Langles:		',cell.get_langles())
	print('Lconstants:	',cell.get_lconstants())

	print(' * * * unit test 1 done * * * : read fhiaims geometry')

	clusters = find_MX_clusters(cell,M='Pb',X='I')		# find clusters in cartesian coordinates
	print(f'Number of Oh MX6 units: {len(clusters)}')
	for cluster in clusters:
		cluster.print_atoms(mode='xyz')

	print(' * * * unit test 2 done * * * : extract Oh clusters')
	print('')

	print(len(clusters))
	print(clusters[0].get_number_of_atoms())
	print('')
	print(clusters[0].print_atoms(mode='cart_gulp'))

	print(' * * * unit test 3 done * * * : check clusters ')

	cluster = merge_clusters(clusters)
	cluster.write_xyz(stdout=True)
	beta_a, beta_b, beta_c = calculate_beta(cluster,C='I',S='Pb')
	print(beta_a)
	print(beta_b)
	print(beta_c)
	print(' * * * unit test 4 done * * * : check cluster merge / beta angles')

	ddlist = calculate_delta_d(clusters,C='Pb',S='I')
	print((np.array(ddlist)*100000.).tolist())
	print(np.array(ddlist).tolist())

	print(' * * * unit test 5 done * * * : delta d')

	print(' # sig sqr')
	sslist = calculate_sigma_squared(clusters,C='Pb',S='I')
	print(sslist)

	print(' * * * unit test 6 done * * * : sigma squared ')



	print(' ---------------------------------------------------------------- ')
	print('	R1 - R0')
	print(' R1 : after VVUQ uncertainty')
	print(' R0 : original sample')
	print(' ---------------------------------------------------------------- ')

	#cell0 = read_fhiaims_cell('/work/e05/e05/wkjee/PAX/VVUQ/Perovskite/UQ_CsPbI/Move_Atoms_E1.3/MoveX/summary/14_aims_init.in')
	cell0 = read_fhiaims_cell('/work/e05/e05/wkjee/PAX/VVUQ/Perovskite/UQ_CsPbI/Move_Atoms_E1.3/MoveA/summary_1-237/aims_init.in')

	if cell0 is not False:
		cell0.write_fhiaims(rule='frac',stdout=True)
		#cell0.write_xyz(stdout=True)

	cell1 = read_fhiaims_cell('/work/e05/e05/wkjee/PAX/VVUQ/Perovskite/UQ_CsPbI/Move_Atoms_E1.3/MoveA/local_1/run__izsdcjof/runs/run_2/geometry.in')
	cell1 = read_fhiaims_cell('/work/e05/e05/wkjee/PAX/VVUQ/Perovskite/UQ_CsPbI/Move_Atoms_E1.3/MoveX/summary/14_aims_init.in')	

	if cell1 is not False:
		cell1.write_fhiaims(rule='frac',stdout=True)
		#cell1.write_xyz(stdout=True)

	deltaR, signtable, Rrmsd = calculate_deltaR(cell1,cell0)

	print(deltaR)
	print(signtable)
	print(Rrmsd)
